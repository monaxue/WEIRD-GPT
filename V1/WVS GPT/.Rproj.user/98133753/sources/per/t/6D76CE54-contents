---
title: "WVS_GPT"
output: html_document
date: "2023-05-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Import libraries
```{r message=FALSE}
library(tidyverse)
library(readxl)
library(psych)
library(hablar)
library(stringr)

```
### Import gpt wvs data
```{r}
#wvs_data <- read_csv("WVS_Cross-National_Wave_7_csv_v5_0.csv")
#head(wvs_data)

gpt_data <- retype(as.data.frame(read_excel("final_cleaned_wvs_gpt_data.xlsx", n_max = 1000)))
gpt_new_data <- retype(as.data.frame(read_excel("revised_final_cleaned_wvs_gpt_data.xlsx", n_max = 1000)))
head(gpt_data)

```
## Larger restructuring of variables in dataset

### Fix core_2 in GPT data
Because we wanted to ask the core_2 question similar to the original question, we had to make coding the question more difficult. Here we are taking GPT answers and recoding them to reflect the original coding. 
```{r}

old_core_2 <- c("Q7", "Q8", "Q9", "Q10", "Q11", "Q12", "Q13", "Q14", "Q15", "Q16", "Q17")
new_core_2 <- c("core_2_1", "core_2_2", "core_2_3", "core_2_4", "core_2_5", "core_2_6", "core_2_7", "core_2_8", "core_2_9", "core_2_10", "core_2_11")

for (i in 1:11) {
  rows <- which(apply(gpt_data == old_core_2[i], MARGIN = 1, FUN = any))
  gpt_new_data[rows, new_core_2[i]] <- "1"
}

gpt_new_data[, new_core_2][is.na(gpt_new_data[, new_core_2])] <- "2"

gpt_new_data <- retype(gpt_new_data)

```


### Fix migration_3 in GPT data

```{r}
migration_3_index <- apply(gpt_data[c("migration_3_1", "migration_3_2", "migration_3_3", "migration_3_4")], MARGIN = 1, function(x) which(x == 1))

for (row in 1:1000){
  if (length(migration_3_index[[row]]) > 1){
    gpt_new_data[row, "migration_3"] = paste(unname(migration_3_index[[row]]), collapse = " or ")
  }
  else {
    gpt_new_data[row, "migration_3"] = paste(unname(migration_3_index[[row]]))
  }
}

```

### Find problematic answer types
```{r}

char_col <- gpt_new_data %>% select_if(is.character)
unique_values <- apply(char_col, 2, unique)
View(unique_values)


```

## The rest of the issues can be fixed wihtin each existing variable. Fix rest of the issues using pipe:

### Function to fix columns with values that give a range between between two numbers. For answers phrased similar  to "Somewhere in between", coverts value to 5.5.
```{r}

fix_between <- function(.data, col){
  numbs1 <- str_extract_all(.data[[col]],"\\(?[0-9,.]+\\)?")
  numbs <- numbs1
  
  for (i in 1:nrow(.data)){
    if (length(numbs1[[i]]) == 0){
      numbs[[i]] <- NA
    }
    if (length(numbs1[[i]]) > 1){
      numbs[[i]] <- sum(as.numeric(unlist(gsub("[,-]","",numbs1[[i]]))))/2
    }
  }
  
  numbs2 <- as.numeric(unlist(numbs))
  numbs2[is.na(numbs2)] <- .data[[col]][is.na(numbs2)]

  numbs2[grep("between", numbs2)] <- 5.5

  data <- .data
  data[[col]] <- numbs2
  data <- retype(data)
  return(data)
}

```

### Pipe: 
* get average scores of variables with a range of answers from 1-10
* flip around 1 and 2 in core_3 to fit original WVS coding
* recode trust_5
* 

```{r}

final_gpt_new_data <- gpt_new_data %>% fix_between("ethics_2_5") %>%
  fix_between("ethics_2_6") %>%
  fix_between("ethics_2_7") %>%
  fix_between("ethics_2_8") %>%
  fix_between("ethics_2_9") %>%
  fix_between("ethics_2_10") %>%
  fix_between("ethics_2_11") %>%
  fix_between("ethics_2_12") %>%
  fix_between("ethics_2_13") %>%
  fix_between("ethics_2_14") %>%
  fix_between("ethics_2_15") %>%
  fix_between("ethics_2_16") %>%
  fix_between("ethics_2_17") %>%
  fix_between("ethics_2_18") %>%
  fix_between("ethics_2_19") %>%
  fix_between("econ_values_1_1") %>%
  fix_between("econ_values_1_2") %>%
  fix_between("econ_values_1_3") %>%
  fix_between("econ_values_1_4") %>%
  fix_between("econ_values_1_5") %>%
  mutate_at(vars(c(core_3_1, core_3_2, core_3_3, core_3_4, core_3_5, core_3_6, core_3_7, core_3_8, core_3_9)), ~recode(., `1` = 2, `2` = 1)) %>% #This had to be done because in our questions, we asked about people they'd like to be neighbors with, whereas the origianl was about people they'd "not like" to be neigbors with. So the "yes" and "no" had to be reverse coded.
  mutate_at(vars(c(trust_5_1, trust_5_2, trust_5_3)), ~recode(., `A` = 1, `B` = 2, `C` = 3)) %>%
  mutate_at(vars(c(political_interest_7_1, political_interest_7_2)), ~recode(., `1` = 1, `2` = 2, `Usually` = 2, `3` = 2, `4` = 3)) %>%
  mutate_at(vars(c(postmat_1_1, postmat_3_1, postmat_3_2)), ~replace(., which(. == "A" | . == "B"), NA)) %>%
  mutate_at(vars(ethics_2_11), ~replace(., which(. == "N/A" | . == "nan"), NA)) %>%
  mutate_at(vars(trust_6_4, trust_6_5, trust_6_9, trust_6_10, security_3_2, religion_2_1, religion_2_2, religion_2_3, religion_2_4, political_interest_3_8, political_interest_4_4, political_interest_6_2, political_interest_6_4, migration_3), ~replace(., which(!(. == "1" | . == "2" | . == "3" | . == "4" | . == "5")), NA))

final_gpt_new_data <- retype(final_gpt_new_data)

  #Continue here
```

### Find more problematic answer types
```{r}

char_col <- final_gpt_new_data %>% select_if(is.character)
unique_values <- apply(char_col, 2, unique)
View(unique_values)


```

### Descriptive statistics
```{r}
psych::describe(final_gpt_new_data)
#write.csv(final_gpt_new_data, "final_final_gpt_wvs_data.csv")

```
### How many responses did we retain after converting to NA for questions that GPT gave multiple responses?
Specifically, after applying 

mutate_at(vars(trust_6_4, trust_6_5, trust_6_9, trust_6_10, security_3_2, religion_2_1, religion_2_2, religion_2_3, religion_2_4, political_interest_3_8, political_interest_4_4, political_interest_6_2, political_interest_6_4, migration_3), ~replace(., which(!(. == "1" | . == "2" | . == "3" | . == "4" | . == "5")), NA))

```{r}
numb_na_df <- final_gpt_new_data[,c("trust_6_4", "trust_6_5", "trust_6_9", "trust_6_10", "security_3_2", "religion_2_1", "religion_2_2", "religion_2_3", "religion_2_4", "political_interest_3_8", "political_interest_4_4", "political_interest_6_2", "political_interest_6_4", "migration_3")]

not_na_counts <- colSums(!is.na(numb_na_df))
avg_not_na_per_col <- sum(na_counts)/(ncol(numb_na_df))

print(na_counts)
print(avg_not_na_per_col)

```